# DataStructureReview
# 자료구조 복습
## 모든 예시는 main.cpp에서 시작, vs2019로 컴파일
1. example
  * example.cpp, example.h
  * main.cpp에서 Example class가 잘 생성되는지 테스트
  ```
#include "example.h"
void main()
{
  Example* ex = new Example();
  ex->print();
  (*ex).print();
}
  ```
2. 정수형 자료의 표현
  * TwosComplement.cpp, TwosComplement.h
  * 정수형 자료(char, int, long long등)이 음수일 때 어떻게 표현되는지, 사칙연산은 어떻게 하는지 확인
  * 음수의 경우 2의 보수로 나타냄
    * ex) char형에서 -7은 7의 모든 비트를 뒤집고 1을 더한값(0b00000111->0b11111000->0b11111001)
  * 결과값이 해당범위를 벗어날 때 벗어난 범위의 값은 사라짐(오버플로)
    * (-128) + (-1) = 127 (0b10000000 + 0b11111111 = 0b01111111)
  * +, -, * 연산은 음수에 대해서도 똑같이 적용되지만, /, % 는 부호비트 따로 숫자비트 따로 계산한다.
    * (-128) / (-3) = 42, (-128) / 3 = -42, 128 / (-3) = -42(int형연산에서)
    * (-128) % (-3) = -2, (-128) % 3 = -2, 128 % (-3) = 2(int형연산에서)
    * (-3) * (128 / (-3)) + 128 % (-3) = 128 성립
3. 실수형 자료의 표현
  * RealNumber.cpp, RealNumber.h
  * 실수형 자료 float이 어떤 방식으로 저장하는 지 확인
  * float형의 저장 방식
    * 부호(1bit), 지수(8bit), 소수(23bit)
    * ex) 2.0 = 0b1.000000 * 2^1, float형에서 저장되는 데이터 : 0b0 10000000 00000000000000000000000(부호+, 0b01111111 + 1, .00000000000000000000000)
  * float형의 특징
    * 지수, 소수의 제한된 비트로 표현이 가능하면 정보 손실 없음 ex) 0.25 = 0b0 01111101 00000000000000000000000
    * 그러나 표현이 불가능하면 정보 손실 있음 ex)0.4 = 0b0 01111101 (1001반복) -> 0b0 01111101 10011001100110011001101(...100/1 에서 반올림?하여 101이 됨) = 0.4000000059604644775390625(실제저장된 값)
    * 표현 범위보다 큰 값을 표현(2^128이상)할 경우 inf로 표시하고 0b0 11111111 00000000000000000000000저장, 이 상태에선 어떤 사칙연산을 해도 inf임
    * 표현 범위보다 작은 값(절댓값이)을 표현할 경우 정보가 손실되어 0b00000000000000000000000000000000저장
    * 가장 큰 자릿수와 가장 작은 자릿수가 2^23배 차이보다 더 크다면 정보 손실
4. 선형 리스트
5. 연결 리스트
